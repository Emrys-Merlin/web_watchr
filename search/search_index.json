{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WebWatchr Documentation This documentation will grow as the project grows. For the moment, you can find all available information in the README.md on the github page and in the API Reference .","title":"WebWatchr Documentation"},{"location":"#webwatchr-documentation","text":"This documentation will grow as the project grows. For the moment, you can find all available information in the README.md on the github page and in the API Reference .","title":"WebWatchr Documentation"},{"location":"api/","text":"API Reference The WebWatchr consists of three parts. web_watchr : This module contains the web_watchr.Watchr class that orchestrates the whole polling, comparing, and alerting. web_watchr.compare : This module contains classes that can be used to check if the state has changed. If you want to implement your own comparer, you need to inherit from web_watchr.compare.AbstractComparer . web_watchr.alert : This module contains classes that can be used to send out alerts of a new state. If you want to implement your own comparer, you need to inherit from web_watchr.alert.AbstractAlerter . web_watchr web_watchr.Watchr Bases: BaseModel Central class that orchestrates the polling, comparing, and alerting process. Attributes: alerter ( AbstractAlerter ) \u2013 The instance is called with the scraped text and is responsible to send out the alert. comparer ( AbstractComparer ) \u2013 The instance is called with the scraped text and is responsible to compare the text with the previous state to check if there are any changes and an alert is necessary. Source code in src/web_watchr/watchr.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Watchr ( BaseModel ): \"\"\"Central class that orchestrates the polling, comparing, and alerting process. Attributes: alerter: The instance is called with the scraped text and is responsible to send out the alert. comparer: The instance is called with the scraped text and is responsible to compare the text with the previous state to check if there are any changes and an alert is necessary. \"\"\" comparer : AbstractComparer = Field ( default_factory = FSComparer ) alerter : AbstractAlerter = Field ( default_factory = PrintAlerter ) _poller : Callable [[ Playwright ], str ] | None = PrivateAttr ( default = None ) @property def poller ( self ) -> Callable [[ Playwright ], str ]: \"\"\"The poller function that scrapes the text from the website.\"\"\" if self . _poller is None : message = \"Please set a poller function using the `set_poller` decorator.\" logger . error ( message ) raise ValueError ( message ) return self . _poller def set_poller ( self , f : Callable [[ Playwright ], str ], ) -> Callable [[ Playwright ], str ]: \"\"\"Decorator to set the poller function. The wrapper returns the function unchanged, but stores it in the `_poller` attribute. Args: f: A function that takes a `Playwright` instance and returns the scraped text. Returns: The function that was passed in. \"\"\" self . _poller = f return f def __call__ ( self , ) -> None : \"\"\"Main method that orchestrates the polling, comparing, and alerting process. When called the poller function is called to scrape the text from the website. The text is then compared to the previous state. If there are changes, an alert is sent out. \"\"\" with sync_playwright () as playwright : result = self . poller ( playwright ) logger . debug ( result ) if self . comparer ( result ) == Status . NO_CHANGES : logger . info ( \"No changes detected.\" ) return logger . info ( \"Changes detected! Sending alert.\" ) self . alerter ( result ) poller : Callable [[ Playwright ], str ] property The poller function that scrapes the text from the website. __call__ () Main method that orchestrates the polling, comparing, and alerting process. When called the poller function is called to scrape the text from the website. The text is then compared to the previous state. If there are changes, an alert is sent out. Source code in src/web_watchr/watchr.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __call__ ( self , ) -> None : \"\"\"Main method that orchestrates the polling, comparing, and alerting process. When called the poller function is called to scrape the text from the website. The text is then compared to the previous state. If there are changes, an alert is sent out. \"\"\" with sync_playwright () as playwright : result = self . poller ( playwright ) logger . debug ( result ) if self . comparer ( result ) == Status . NO_CHANGES : logger . info ( \"No changes detected.\" ) return logger . info ( \"Changes detected! Sending alert.\" ) self . alerter ( result ) set_poller ( f ) Decorator to set the poller function. The wrapper returns the function unchanged, but stores it in the _poller attribute. Parameters: f ( Callable [[ Playwright ], str ] ) \u2013 A function that takes a Playwright instance and returns the scraped text. Returns: Callable [[ Playwright ], str ] \u2013 The function that was passed in. Source code in src/web_watchr/watchr.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def set_poller ( self , f : Callable [[ Playwright ], str ], ) -> Callable [[ Playwright ], str ]: \"\"\"Decorator to set the poller function. The wrapper returns the function unchanged, but stores it in the `_poller` attribute. Args: f: A function that takes a `Playwright` instance and returns the scraped text. Returns: The function that was passed in. \"\"\" self . _poller = f return f web_watchr.compare web_watchr.compare.Status Bases: Enum Enum representing the status of a comparison. Convenience enum because I got confused with booleans. Attributes: CHANGED \u2013 The text has changed. NO_CHANGES \u2013 The text has not changed. Source code in src/web_watchr/compare/abstract_comparer.py 7 8 9 10 11 12 13 14 15 16 17 18 class Status ( Enum ): \"\"\"Enum representing the status of a comparison. Convenience enum because I got confused with booleans. Attributes: CHANGED: The text has changed. NO_CHANGES: The text has not changed. \"\"\" CHANGED = auto () NO_CHANGES = auto () web_watchr.compare.AbstractComparer Bases: BaseModel , ABC Decide if a text has changed. Source code in src/web_watchr/compare/abstract_comparer.py 21 22 23 24 25 26 27 28 29 30 31 class AbstractComparer ( BaseModel , ABC ): \"\"\"Decide if a text has changed.\"\"\" @abstractmethod def __call__ ( self , text : str ) -> Status : \"\"\"Decide if a text has changed. A new comparer must implement this method. The method should compare the text with the previous state and return the status of the comparison. \"\"\" ... __call__ ( text ) abstractmethod Decide if a text has changed. A new comparer must implement this method. The method should compare the text with the previous state and return the status of the comparison. Source code in src/web_watchr/compare/abstract_comparer.py 24 25 26 27 28 29 30 31 @abstractmethod def __call__ ( self , text : str ) -> Status : \"\"\"Decide if a text has changed. A new comparer must implement this method. The method should compare the text with the previous state and return the status of the comparison. \"\"\" ... web_watchr.compare.DummyComparer Bases: AbstractComparer A comparer that always returns Status.CHANGED . Source code in src/web_watchr/compare/dummy_comparer.py 4 5 6 7 8 9 class DummyComparer ( AbstractComparer ): \"\"\"A comparer that always returns [`Status.CHANGED`][web_watchr.compare.Status].\"\"\" def __call__ ( self , text : str ) -> Status : \"\"\"Always return [`Status.CHANGED`][web_watchr.compare.Status].\"\"\" return Status . CHANGED __call__ ( text ) Always return Status.CHANGED . Source code in src/web_watchr/compare/dummy_comparer.py 7 8 9 def __call__ ( self , text : str ) -> Status : \"\"\"Always return [`Status.CHANGED`][web_watchr.compare.Status].\"\"\" return Status . CHANGED web_watchr.compare.FSComparer Bases: AbstractComparer A comparer that compares the text with the content of a file. Attributes: cache_dir ( Path ) \u2013 The directory where the cache file is stored. Defaults to ~/.local/share/website_monitoring_bot/cache . send_on_missing ( bool ) \u2013 Whether to send a notification if the cache file is missing. identifier ( str ) \u2013 The identifier used for the cache file. Source code in src/web_watchr/compare/fs_comparer.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class FSComparer ( AbstractComparer ): \"\"\"A comparer that compares the text with the content of a file. Attributes: cache_dir: The directory where the cache file is stored. Defaults to `~/.local/share/website_monitoring_bot/cache`. send_on_missing: Whether to send a notification if the cache file is missing. identifier: The identifier used for the cache file. \"\"\" cache_dir : Path = Path ( \"~/.local/share/website_monitoring_bot/cache\" ) . expanduser () send_on_missing : bool = False identifier : str = \"fs_comparer\" _cache_path : Path | None = None @property def cache_path ( self ) -> Path : \"\"\"The path to the cache file. Creates the cache directory if it does not exist. \"\"\" if self . _cache_path is None : self . _cache_path = self . cache_dir / f \" { self . identifier } .txt\" if not self . cache_dir . exists (): logger . debug ( f \"Creating cache directory: { self . cache_dir } \" ) self . cache_dir . mkdir ( parents = True ) return self . _cache_path def __call__ ( self , text : str ) -> Status : \"\"\"Compare the text with the content of the cache file. Args: text: The text to compare with the cache file. Returns: [`Status.CHANGED`][web_watchr.compare.Status] if the text is different from the cache file. [`Status.NO_CHANGES`][web_watchr.compare.Status] if the text is the same as the cache file. If the cache file is missing, it returns [`Status.CHANGED`][web_watchr.compare.Status] if `send_on_missing` is `True`. \"\"\" if not self . cache_path . exists (): logger . debug ( f \"Cache file not found: { self . cache_path } . Saving new state.\" ) self . _save ( new_state = text ) return Status . CHANGED if self . send_on_missing else Status . NO_CHANGES if not self . _equal_to_cache ( new_state = text ): self . _save ( new_state = text ) return Status . CHANGED return Status . NO_CHANGES def _load ( self ) -> str : with open ( self . cache_path , \"r\" ) as f : return f . read () def _equal_to_cache ( self , * , new_state : str ) -> bool : old_state = self . _load () return old_state == new_state def _save ( self , * , new_state : str ): with open ( self . cache_path , \"w\" ) as f : f . write ( new_state ) cache_path : Path property The path to the cache file. Creates the cache directory if it does not exist. __call__ ( text ) Compare the text with the content of the cache file. Parameters: text ( str ) \u2013 The text to compare with the cache file. Returns: Status \u2013 Status.CHANGED if the text is different from the cache file. Status \u2013 Status.NO_CHANGES if the text is the same as the cache file. Status \u2013 If the cache file is missing, it returns Status.CHANGED if send_on_missing is True . Source code in src/web_watchr/compare/fs_comparer.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def __call__ ( self , text : str ) -> Status : \"\"\"Compare the text with the content of the cache file. Args: text: The text to compare with the cache file. Returns: [`Status.CHANGED`][web_watchr.compare.Status] if the text is different from the cache file. [`Status.NO_CHANGES`][web_watchr.compare.Status] if the text is the same as the cache file. If the cache file is missing, it returns [`Status.CHANGED`][web_watchr.compare.Status] if `send_on_missing` is `True`. \"\"\" if not self . cache_path . exists (): logger . debug ( f \"Cache file not found: { self . cache_path } . Saving new state.\" ) self . _save ( new_state = text ) return Status . CHANGED if self . send_on_missing else Status . NO_CHANGES if not self . _equal_to_cache ( new_state = text ): self . _save ( new_state = text ) return Status . CHANGED return Status . NO_CHANGES web_watchr.alert web_watchr.alert.AbstractAlerter Bases: BaseModel , ABC Send an alert. Source code in src/web_watchr/alert/abstract_alerter.py 6 7 8 9 10 11 12 13 14 15 16 17 18 class AbstractAlerter ( BaseModel , ABC ): \"\"\"Send an alert.\"\"\" @abstractmethod def __call__ ( self , text : str ) -> None : \"\"\"Send an alert. A new alerter must implement this method. The method should send the alert with the given text. Args: text: The text of the alert. \"\"\" ... __call__ ( text ) abstractmethod Send an alert. A new alerter must implement this method. The method should send the alert with the given text. Parameters: text ( str ) \u2013 The text of the alert. Source code in src/web_watchr/alert/abstract_alerter.py 9 10 11 12 13 14 15 16 17 18 @abstractmethod def __call__ ( self , text : str ) -> None : \"\"\"Send an alert. A new alerter must implement this method. The method should send the alert with the given text. Args: text: The text of the alert. \"\"\" ... web_watchr.alert.PrintAlerter Bases: AbstractAlerter Print the alert to the standard output. Source code in src/web_watchr/alert/print_alerter.py 4 5 6 7 8 9 10 11 12 13 class PrintAlerter ( AbstractAlerter ): \"\"\"Print the alert to the standard output.\"\"\" def __call__ ( self , text : str ) -> None : \"\"\"Print the alert to the standard output. Args: text: The text of the alert. \"\"\" print ( text ) __call__ ( text ) Print the alert to the standard output. Parameters: text ( str ) \u2013 The text of the alert. Source code in src/web_watchr/alert/print_alerter.py 7 8 9 10 11 12 13 def __call__ ( self , text : str ) -> None : \"\"\"Print the alert to the standard output. Args: text: The text of the alert. \"\"\" print ( text ) web_watchr.alert.TelegramAlerter Bases: AbstractAlerter Sends a message to a telegram chat. For this alerter to work, you need to create a telegram bot and get its token . Furthermore, the bot needs to be added to the chat you want to send messages to and you need to retrieve the chat ID of the chat (e.g., like this ). Attributes: token ( str ) \u2013 The token of the telegram bot. chat_id ( str ) \u2013 The chat ID to send the message to. Source code in src/web_watchr/alert/telegram_alerter.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class TelegramAlerter ( AbstractAlerter ): \"\"\"Sends a message to a telegram chat. For this alerter to work, you need to [create a telegram bot and get its token](https://core.telegram.org/bots/tutorial#obtain-your-bot-token). Furthermore, the bot needs to be added to the chat you want to send messages to and you need to retrieve the chat ID of the chat (e.g., like [this](https://stackoverflow.com/a/32572159/9685500)). Attributes: token: The token of the telegram bot. chat_id: The chat ID to send the message to. \"\"\" token : str chat_id : str _bot : Bot | None = None @property def bot ( self ) -> Bot : \"\"\"Telegram bot instance\"\"\" if self . _bot is None : self . _bot = Bot ( token = self . token ) return self . _bot def __call__ ( self , text : str ) -> None : \"\"\"Send a message to a telegram chat. Args: text: The text of the message. \"\"\" logger . debug ( f \"Sending message ' { text } ' to telegram.\" ) run ( self . bot . send_message ( chat_id = self . chat_id , text = text )) bot : Bot property Telegram bot instance __call__ ( text ) Send a message to a telegram chat. Parameters: text ( str ) \u2013 The text of the message. Source code in src/web_watchr/alert/telegram_alerter.py 34 35 36 37 38 39 40 41 def __call__ ( self , text : str ) -> None : \"\"\"Send a message to a telegram chat. Args: text: The text of the message. \"\"\" logger . debug ( f \"Sending message ' { text } ' to telegram.\" ) run ( self . bot . send_message ( chat_id = self . chat_id , text = text ))","title":"API Reference"},{"location":"api/#api-reference","text":"The WebWatchr consists of three parts. web_watchr : This module contains the web_watchr.Watchr class that orchestrates the whole polling, comparing, and alerting. web_watchr.compare : This module contains classes that can be used to check if the state has changed. If you want to implement your own comparer, you need to inherit from web_watchr.compare.AbstractComparer . web_watchr.alert : This module contains classes that can be used to send out alerts of a new state. If you want to implement your own comparer, you need to inherit from web_watchr.alert.AbstractAlerter .","title":"API Reference"},{"location":"api/#web_watchr","text":"","title":"web_watchr"},{"location":"api/#web_watchr.Watchr","text":"Bases: BaseModel Central class that orchestrates the polling, comparing, and alerting process. Attributes: alerter ( AbstractAlerter ) \u2013 The instance is called with the scraped text and is responsible to send out the alert. comparer ( AbstractComparer ) \u2013 The instance is called with the scraped text and is responsible to compare the text with the previous state to check if there are any changes and an alert is necessary. Source code in src/web_watchr/watchr.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Watchr ( BaseModel ): \"\"\"Central class that orchestrates the polling, comparing, and alerting process. Attributes: alerter: The instance is called with the scraped text and is responsible to send out the alert. comparer: The instance is called with the scraped text and is responsible to compare the text with the previous state to check if there are any changes and an alert is necessary. \"\"\" comparer : AbstractComparer = Field ( default_factory = FSComparer ) alerter : AbstractAlerter = Field ( default_factory = PrintAlerter ) _poller : Callable [[ Playwright ], str ] | None = PrivateAttr ( default = None ) @property def poller ( self ) -> Callable [[ Playwright ], str ]: \"\"\"The poller function that scrapes the text from the website.\"\"\" if self . _poller is None : message = \"Please set a poller function using the `set_poller` decorator.\" logger . error ( message ) raise ValueError ( message ) return self . _poller def set_poller ( self , f : Callable [[ Playwright ], str ], ) -> Callable [[ Playwright ], str ]: \"\"\"Decorator to set the poller function. The wrapper returns the function unchanged, but stores it in the `_poller` attribute. Args: f: A function that takes a `Playwright` instance and returns the scraped text. Returns: The function that was passed in. \"\"\" self . _poller = f return f def __call__ ( self , ) -> None : \"\"\"Main method that orchestrates the polling, comparing, and alerting process. When called the poller function is called to scrape the text from the website. The text is then compared to the previous state. If there are changes, an alert is sent out. \"\"\" with sync_playwright () as playwright : result = self . poller ( playwright ) logger . debug ( result ) if self . comparer ( result ) == Status . NO_CHANGES : logger . info ( \"No changes detected.\" ) return logger . info ( \"Changes detected! Sending alert.\" ) self . alerter ( result )","title":"Watchr"},{"location":"api/#web_watchr.Watchr.poller","text":"The poller function that scrapes the text from the website.","title":"poller"},{"location":"api/#web_watchr.Watchr.__call__","text":"Main method that orchestrates the polling, comparing, and alerting process. When called the poller function is called to scrape the text from the website. The text is then compared to the previous state. If there are changes, an alert is sent out. Source code in src/web_watchr/watchr.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __call__ ( self , ) -> None : \"\"\"Main method that orchestrates the polling, comparing, and alerting process. When called the poller function is called to scrape the text from the website. The text is then compared to the previous state. If there are changes, an alert is sent out. \"\"\" with sync_playwright () as playwright : result = self . poller ( playwright ) logger . debug ( result ) if self . comparer ( result ) == Status . NO_CHANGES : logger . info ( \"No changes detected.\" ) return logger . info ( \"Changes detected! Sending alert.\" ) self . alerter ( result )","title":"__call__"},{"location":"api/#web_watchr.Watchr.set_poller","text":"Decorator to set the poller function. The wrapper returns the function unchanged, but stores it in the _poller attribute. Parameters: f ( Callable [[ Playwright ], str ] ) \u2013 A function that takes a Playwright instance and returns the scraped text. Returns: Callable [[ Playwright ], str ] \u2013 The function that was passed in. Source code in src/web_watchr/watchr.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def set_poller ( self , f : Callable [[ Playwright ], str ], ) -> Callable [[ Playwright ], str ]: \"\"\"Decorator to set the poller function. The wrapper returns the function unchanged, but stores it in the `_poller` attribute. Args: f: A function that takes a `Playwright` instance and returns the scraped text. Returns: The function that was passed in. \"\"\" self . _poller = f return f","title":"set_poller"},{"location":"api/#web_watchrcompare","text":"","title":"web_watchr.compare"},{"location":"api/#web_watchr.compare.Status","text":"Bases: Enum Enum representing the status of a comparison. Convenience enum because I got confused with booleans. Attributes: CHANGED \u2013 The text has changed. NO_CHANGES \u2013 The text has not changed. Source code in src/web_watchr/compare/abstract_comparer.py 7 8 9 10 11 12 13 14 15 16 17 18 class Status ( Enum ): \"\"\"Enum representing the status of a comparison. Convenience enum because I got confused with booleans. Attributes: CHANGED: The text has changed. NO_CHANGES: The text has not changed. \"\"\" CHANGED = auto () NO_CHANGES = auto ()","title":"Status"},{"location":"api/#web_watchr.compare.AbstractComparer","text":"Bases: BaseModel , ABC Decide if a text has changed. Source code in src/web_watchr/compare/abstract_comparer.py 21 22 23 24 25 26 27 28 29 30 31 class AbstractComparer ( BaseModel , ABC ): \"\"\"Decide if a text has changed.\"\"\" @abstractmethod def __call__ ( self , text : str ) -> Status : \"\"\"Decide if a text has changed. A new comparer must implement this method. The method should compare the text with the previous state and return the status of the comparison. \"\"\" ...","title":"AbstractComparer"},{"location":"api/#web_watchr.compare.AbstractComparer.__call__","text":"Decide if a text has changed. A new comparer must implement this method. The method should compare the text with the previous state and return the status of the comparison. Source code in src/web_watchr/compare/abstract_comparer.py 24 25 26 27 28 29 30 31 @abstractmethod def __call__ ( self , text : str ) -> Status : \"\"\"Decide if a text has changed. A new comparer must implement this method. The method should compare the text with the previous state and return the status of the comparison. \"\"\" ...","title":"__call__"},{"location":"api/#web_watchr.compare.DummyComparer","text":"Bases: AbstractComparer A comparer that always returns Status.CHANGED . Source code in src/web_watchr/compare/dummy_comparer.py 4 5 6 7 8 9 class DummyComparer ( AbstractComparer ): \"\"\"A comparer that always returns [`Status.CHANGED`][web_watchr.compare.Status].\"\"\" def __call__ ( self , text : str ) -> Status : \"\"\"Always return [`Status.CHANGED`][web_watchr.compare.Status].\"\"\" return Status . CHANGED","title":"DummyComparer"},{"location":"api/#web_watchr.compare.DummyComparer.__call__","text":"Always return Status.CHANGED . Source code in src/web_watchr/compare/dummy_comparer.py 7 8 9 def __call__ ( self , text : str ) -> Status : \"\"\"Always return [`Status.CHANGED`][web_watchr.compare.Status].\"\"\" return Status . CHANGED","title":"__call__"},{"location":"api/#web_watchr.compare.FSComparer","text":"Bases: AbstractComparer A comparer that compares the text with the content of a file. Attributes: cache_dir ( Path ) \u2013 The directory where the cache file is stored. Defaults to ~/.local/share/website_monitoring_bot/cache . send_on_missing ( bool ) \u2013 Whether to send a notification if the cache file is missing. identifier ( str ) \u2013 The identifier used for the cache file. Source code in src/web_watchr/compare/fs_comparer.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class FSComparer ( AbstractComparer ): \"\"\"A comparer that compares the text with the content of a file. Attributes: cache_dir: The directory where the cache file is stored. Defaults to `~/.local/share/website_monitoring_bot/cache`. send_on_missing: Whether to send a notification if the cache file is missing. identifier: The identifier used for the cache file. \"\"\" cache_dir : Path = Path ( \"~/.local/share/website_monitoring_bot/cache\" ) . expanduser () send_on_missing : bool = False identifier : str = \"fs_comparer\" _cache_path : Path | None = None @property def cache_path ( self ) -> Path : \"\"\"The path to the cache file. Creates the cache directory if it does not exist. \"\"\" if self . _cache_path is None : self . _cache_path = self . cache_dir / f \" { self . identifier } .txt\" if not self . cache_dir . exists (): logger . debug ( f \"Creating cache directory: { self . cache_dir } \" ) self . cache_dir . mkdir ( parents = True ) return self . _cache_path def __call__ ( self , text : str ) -> Status : \"\"\"Compare the text with the content of the cache file. Args: text: The text to compare with the cache file. Returns: [`Status.CHANGED`][web_watchr.compare.Status] if the text is different from the cache file. [`Status.NO_CHANGES`][web_watchr.compare.Status] if the text is the same as the cache file. If the cache file is missing, it returns [`Status.CHANGED`][web_watchr.compare.Status] if `send_on_missing` is `True`. \"\"\" if not self . cache_path . exists (): logger . debug ( f \"Cache file not found: { self . cache_path } . Saving new state.\" ) self . _save ( new_state = text ) return Status . CHANGED if self . send_on_missing else Status . NO_CHANGES if not self . _equal_to_cache ( new_state = text ): self . _save ( new_state = text ) return Status . CHANGED return Status . NO_CHANGES def _load ( self ) -> str : with open ( self . cache_path , \"r\" ) as f : return f . read () def _equal_to_cache ( self , * , new_state : str ) -> bool : old_state = self . _load () return old_state == new_state def _save ( self , * , new_state : str ): with open ( self . cache_path , \"w\" ) as f : f . write ( new_state )","title":"FSComparer"},{"location":"api/#web_watchr.compare.FSComparer.cache_path","text":"The path to the cache file. Creates the cache directory if it does not exist.","title":"cache_path"},{"location":"api/#web_watchr.compare.FSComparer.__call__","text":"Compare the text with the content of the cache file. Parameters: text ( str ) \u2013 The text to compare with the cache file. Returns: Status \u2013 Status.CHANGED if the text is different from the cache file. Status \u2013 Status.NO_CHANGES if the text is the same as the cache file. Status \u2013 If the cache file is missing, it returns Status.CHANGED if send_on_missing is True . Source code in src/web_watchr/compare/fs_comparer.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def __call__ ( self , text : str ) -> Status : \"\"\"Compare the text with the content of the cache file. Args: text: The text to compare with the cache file. Returns: [`Status.CHANGED`][web_watchr.compare.Status] if the text is different from the cache file. [`Status.NO_CHANGES`][web_watchr.compare.Status] if the text is the same as the cache file. If the cache file is missing, it returns [`Status.CHANGED`][web_watchr.compare.Status] if `send_on_missing` is `True`. \"\"\" if not self . cache_path . exists (): logger . debug ( f \"Cache file not found: { self . cache_path } . Saving new state.\" ) self . _save ( new_state = text ) return Status . CHANGED if self . send_on_missing else Status . NO_CHANGES if not self . _equal_to_cache ( new_state = text ): self . _save ( new_state = text ) return Status . CHANGED return Status . NO_CHANGES","title":"__call__"},{"location":"api/#web_watchralert","text":"","title":"web_watchr.alert"},{"location":"api/#web_watchr.alert.AbstractAlerter","text":"Bases: BaseModel , ABC Send an alert. Source code in src/web_watchr/alert/abstract_alerter.py 6 7 8 9 10 11 12 13 14 15 16 17 18 class AbstractAlerter ( BaseModel , ABC ): \"\"\"Send an alert.\"\"\" @abstractmethod def __call__ ( self , text : str ) -> None : \"\"\"Send an alert. A new alerter must implement this method. The method should send the alert with the given text. Args: text: The text of the alert. \"\"\" ...","title":"AbstractAlerter"},{"location":"api/#web_watchr.alert.AbstractAlerter.__call__","text":"Send an alert. A new alerter must implement this method. The method should send the alert with the given text. Parameters: text ( str ) \u2013 The text of the alert. Source code in src/web_watchr/alert/abstract_alerter.py 9 10 11 12 13 14 15 16 17 18 @abstractmethod def __call__ ( self , text : str ) -> None : \"\"\"Send an alert. A new alerter must implement this method. The method should send the alert with the given text. Args: text: The text of the alert. \"\"\" ...","title":"__call__"},{"location":"api/#web_watchr.alert.PrintAlerter","text":"Bases: AbstractAlerter Print the alert to the standard output. Source code in src/web_watchr/alert/print_alerter.py 4 5 6 7 8 9 10 11 12 13 class PrintAlerter ( AbstractAlerter ): \"\"\"Print the alert to the standard output.\"\"\" def __call__ ( self , text : str ) -> None : \"\"\"Print the alert to the standard output. Args: text: The text of the alert. \"\"\" print ( text )","title":"PrintAlerter"},{"location":"api/#web_watchr.alert.PrintAlerter.__call__","text":"Print the alert to the standard output. Parameters: text ( str ) \u2013 The text of the alert. Source code in src/web_watchr/alert/print_alerter.py 7 8 9 10 11 12 13 def __call__ ( self , text : str ) -> None : \"\"\"Print the alert to the standard output. Args: text: The text of the alert. \"\"\" print ( text )","title":"__call__"},{"location":"api/#web_watchr.alert.TelegramAlerter","text":"Bases: AbstractAlerter Sends a message to a telegram chat. For this alerter to work, you need to create a telegram bot and get its token . Furthermore, the bot needs to be added to the chat you want to send messages to and you need to retrieve the chat ID of the chat (e.g., like this ). Attributes: token ( str ) \u2013 The token of the telegram bot. chat_id ( str ) \u2013 The chat ID to send the message to. Source code in src/web_watchr/alert/telegram_alerter.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class TelegramAlerter ( AbstractAlerter ): \"\"\"Sends a message to a telegram chat. For this alerter to work, you need to [create a telegram bot and get its token](https://core.telegram.org/bots/tutorial#obtain-your-bot-token). Furthermore, the bot needs to be added to the chat you want to send messages to and you need to retrieve the chat ID of the chat (e.g., like [this](https://stackoverflow.com/a/32572159/9685500)). Attributes: token: The token of the telegram bot. chat_id: The chat ID to send the message to. \"\"\" token : str chat_id : str _bot : Bot | None = None @property def bot ( self ) -> Bot : \"\"\"Telegram bot instance\"\"\" if self . _bot is None : self . _bot = Bot ( token = self . token ) return self . _bot def __call__ ( self , text : str ) -> None : \"\"\"Send a message to a telegram chat. Args: text: The text of the message. \"\"\" logger . debug ( f \"Sending message ' { text } ' to telegram.\" ) run ( self . bot . send_message ( chat_id = self . chat_id , text = text ))","title":"TelegramAlerter"},{"location":"api/#web_watchr.alert.TelegramAlerter.bot","text":"Telegram bot instance","title":"bot"},{"location":"api/#web_watchr.alert.TelegramAlerter.__call__","text":"Send a message to a telegram chat. Parameters: text ( str ) \u2013 The text of the message. Source code in src/web_watchr/alert/telegram_alerter.py 34 35 36 37 38 39 40 41 def __call__ ( self , text : str ) -> None : \"\"\"Send a message to a telegram chat. Args: text: The text of the message. \"\"\" logger . debug ( f \"Sending message ' { text } ' to telegram.\" ) run ( self . bot . send_message ( chat_id = self . chat_id , text = text ))","title":"__call__"}]}